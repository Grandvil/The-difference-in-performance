# Разница в производительности

## Описание задачи
Оценка производительности двух вариантов мап: ConcurrentHashMap и многопоточной обертки над HashMap `Collections.synchronizedMap(new HashMap<>()`

## Работа программы
1. Создание двух мап разных типов, хранящих Integer
2. Генерация массива чисел для добавления в мапы
3. Эмуляция чтения и записи для каждой из мап в несколько потоков. Проведение обоих экспериментов с замером времени и выводом результатов на консоль.
4. Попробовать существенно увеличить или уменьшить количество добавляемых элементов для повторного эксперимента. 

## Комментарий к задаче

Результаты выполнения будут зависеть от оборудования и конфигурации. В большинстве случаев обнаружено, что ConcurrentHashMap демонстрирует лучшую производительность, особенно при увеличении NUM_ELEMENTS. 

- При 10 000 000 значениях среднее время выполнения для ConcurrentHashMap - 16 183 мс, для synchronizedMap - 33 029 мс.
- При 100 000 значениях среднее время выполнения для ConcurrentHashMap - 200 мс, для synchronizedMap - 226 мс.
- При 10 значениях среднее время выполнения для ConcurrentHashMap - 8,6 мс, для synchronizedMap - 3,8 мс.

### Изменение NUM_ELEMENTS

- При увеличении количества элементов производительность ConcurrentHashMap значительно превосходит synchronizedMap, так как ConcurrentHashMap позволяет нескольким потокам выполнять операции записи и чтения одновременно, в то время как synchronizedMap сериализует доступ.
- При меньшем количестве элементов различие в производительности между ConcurrentHashMap и synchronizedMap может быть менее заметным, но ConcurrentHashMap все равно, как правило, будет немного быстрее из-за более оптимизированной реализации.
- При совсем незначительном количестве элементов (10) ConcurrentHashMap показывает результаты хуже. Возможно при таком малом размере данных накладные расходы на синхронизацию в synchronizedMap могут оказаться незначительными, а ConcurrentHashMap может иметь больше накладных расходов из-за более сложной реализации для конкурентного доступа. Также JVM может оптимизировать код во время выполнения, и это могло повлиять на результаты тестирования. 

